<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>blog of Monsmile</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog of gaolanyu">
<meta property="og:type" content="website">
<meta property="og:title" content="blog of Monsmile">
<meta property="og:url" content="https://monsmile.github.io/index.html">
<meta property="og:site_name" content="blog of Monsmile">
<meta property="og:description" content="blog of gaolanyu">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="blog of Monsmile">
<meta name="twitter:description" content="blog of gaolanyu">
  
    <link rel="alternate" href="/atom.xml" title="blog of Monsmile" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">blog of Monsmile</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://monsmile.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="mybatis-获取insert数据的主键" class="article article-type-mybatis" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/获取insert数据的主键/" class="article-date">
  <time datetime="2017-01-04T17:34:51.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mybatis/">mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/获取insert数据的主键/">mybatis获取insert数据的主键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： mybatis</p>
<hr>
<p>在mapper.xml文件中的中添加属性useGeneratedKeys=”true” keyProperty=”主键的对应的实体类中的属性”。<br>举个例子</p>
<pre><code> 执行insert操作之后mybatis会自动把主键赋给对象

&lt;insert id=&quot;save&quot; parameterType=&quot;com.igeekhome.ex.pojo.ClassInfo&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;classId&quot;&gt;
insert into classInfo(className) values(#{className})
&lt;/insert&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/获取insert数据的主键/" data-id="cixiraj3f000nncp8hstf1lmo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springMVC常用注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/springMVC常用注解/" class="article-date">
  <time datetime="2017-01-04T17:32:03.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/springMVC常用注解/">springMVC常用注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： spring</p>
<hr>
<p>spring mvc常用的注解： 介绍。</p>
<p>@Controller</p>
<p>@Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为 类名称开头字母小写,你也可以自己指定，如下</p>
<p>方法一： @Controller public class TestController {}</p>
<p>方法二： @Controller(“tmpController”) public class TestController {} @RequestMapping</p>
<p>1.@RequestMapping用来定义访问的URL，你可以为整个类定义一个 @RequestMapping，或者为每个方法指定一个。 把@RequestMapping放在类级别上，这可令它与方法级别上的 @RequestMapping注解协同工作，取得缩小选择范围的效果。</p>
<p>例如： @RequestMapping(“/test”)</p>
<p>public class TestController {} 则，该类下的所有访问路径都在/test之下。</p>
<p>2.将@RequestMapping用于整个类不是必须的，如果没有配置，所有的方法 的访问路径配置将是完全独立的，没有任何关联。</p>
<p>3.完整的参数项为：@RequestMapping(value=””,method = {“”,””},headers={},params={“”,””})，</p>
<p>各参数说明如下： value :String[] 设置访问地址 method: RequestMethod[]设置访问方式，字符数组，查看RequestMethod 类，</p>
<p>包括GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE,常用 RequestMethod.GET，RequestMethod.POST headers:String[] headers一般结合method = RequestMethod.POST使用 params: String[] 访问参数设置，字符数组</p>
<p>例如：userId=id</p>
<p>4.value的配置还可以采用模版变量的形式，例如：</p>
<p>@RequestMapping (value=”/owners/{ownerId}”, method=RequestMethod.GET)</p>
<p>，这点将在介绍@PathVariable中详细说明。</p>
<p>5.@RequestMapping params的补充说明，你可以通过设置参数条件来限制访问地址，例如params=”myParam=myValue”表达式，访问地址中参数只有包含了该规定的值”myParam=myValue”才能匹配得上，类似”myParam”之类的表达式也是支持的，表示当前请求的地址必须有该参数(参数的值可以是任意)，”!myParam”之类的表达式表明当前请求的地址不能包含具体指定的参数”myParam”。</p>
<p>6.有一点需要注意的，如果为类定义了访问地址为<em>.do,</em>.html之类的，则在方法级的@RequestMapping，不能再定义value值，否则会报错，例如Java代码</p>
<p>@RequestMapping(“/bbs.do”)</p>
<p>public class BbsController {</p>
<p> @RequestMapping(params = “method=getList”)</p>
<p>public String getList() {  return “list”; }</p>
<p> @RequestMapping(value= “/spList”)</p>
<p>public String getSpecialList() {  return “splist”;  }</p>
<p> }</p>
<p>如上例：</p>
<p>/bbs.do?method=getList 可以访问到方法getList() ；而访问/bbs.do/spList</p>
<p>则会报错.</p>
<p>@PathVariable</p>
<p> 1.@PathVariable用于方法中的参数，表示方法参数绑定到地址URL的模板变量。例如：</p>
<p>@RequestMapping(value=”/owners/{ownerId}”,    method=RequestMethod.GET)    public String findOwner(@PathVariable String ownerId, Model    model) {      Owner owner = ownerService.findOwner(ownerId);       model.addAttribute(“owner”, owner);       return “displayOwner”;   } </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/springMVC常用注解/" data-id="cixiraj37000fncp8cqqy345g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL修改root密码的多种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/MySQL修改root密码的多种方法/" class="article-date">
  <time datetime="2017-01-04T17:27:51.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/MySQL修改root密码的多种方法/">MySQL修改root密码的多种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： mysql</p>
<hr>
<p>方法1： 用SET PASSWORD命令</p>
<p>mysql -u root</p>
<p>mysql&gt; SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’);</p>
<p>方法2：用mysqladmin</p>
<p>mysqladmin -u root password “newpass”</p>
<p>如果root已经设置过密码，采用如下方法</p>
<p>mysqladmin -u root password oldpass “newpass”</p>
<p>方法3： 用UPDATE直接编辑user表</p>
<p>mysql -u root</p>
<p>mysql&gt; use mysql;</p>
<p>mysql&gt; UPDATE user SET Password = PASSWORD(‘newpass’) WHERE user = ‘root’;</p>
<p>mysql&gt; FLUSH PRIVILEGES;</p>
<p>在丢失root密码的时候，可以这样</p>
<p>mysqld_safe –skip-grant-tables&amp;</p>
<p>mysql -u root mysql</p>
<p>mysql&gt; UPDATE user SET password=PASSWORD(“new password”) WHERE user=’root’;</p>
<p>mysql&gt; FLUSH PRIVILEGES;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/MySQL修改root密码的多种方法/" data-id="cixiraj2n0000ncp8abde3n7m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql数据库备份与恢复操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/mysql数据库备份与恢复操作/" class="article-date">
  <time datetime="2017-01-04T17:24:49.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/mysql数据库备份与恢复操作/">mysql数据库备份与恢复操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>备份数据库：</p>
<p>[sql] view plain copy<br>备份MySQL数据库的命令</p>
<p>mysqldump -hhostname -uusername -ppassword databasename &gt; backupfile.sql</p>
<p>备份MySQL数据库为带删除表的格式<br>备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。</p>
<p>mysqldump -–add-drop-table -uusername -ppassword databasename &gt; backupfile.sql</p>
<p>直接将MySQL数据库压缩备份</p>
<p>mysqldump -hhostname -uusername -ppassword databasename | gzip &gt; backupfile.sql.gz</p>
<p>备份MySQL数据库某个(些)表</p>
<p>mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 &gt; backupfile.sql</p>
<p>同时备份多个MySQL数据库</p>
<p>mysqldump -hhostname -uusername -ppassword –databases databasename1 databasename2 databasename3 &gt; multibackupfile.sql</p>
<p>仅仅备份数据库结构</p>
<p>mysqldump –no-data –databases databasename1 databasename2 databasename3 &gt; structurebackupfile.sql</p>
<p>备份服务器上所有数据库</p>
<p>mysqldump –all-databases &gt; allbackupfile.sql</p>
<p>还原MySQL数据库的命令</p>
<p>mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</p>
<p>还原压缩的MySQL数据库</p>
<p>gunzip &lt; backupfile.sql.gz | mysql -uusername -ppassword databasename</p>
<p>将数据库转移到新服务器</p>
<p>mysqldump -uusername -ppassword databasename | mysql –host=<em>.</em>.<em>.</em> -C databasename<br>try {<br>Runtime rt = Runtime.getRuntime();<br>String cmd =”mysqldump -h localhost -uroot -p1234 test blog_user &gt; e:/mysql.sql”; //一定要加 -h localhost(或是服务器IP地址)<br>rt.exec(“cmd /c “ + cmd);<br>System.out.println(“备份成功!”);<br>} catch (IOException e) {<br>System.out.println(“备份失败!”);<br>e.printStackTrace();<br>}</p>
<p>try {<br>Runtime rt = Runtime.getRuntime();<br>String cmd =”mysqldump -h localhost -uroot -p1234 test blog_user &gt; e:/mysql.sql”; //一定要加 -h localhost(或是服务器IP地址)<br>Process process =rt.exec(“cmd /c “ + cmd);<br>InputStreamReader isr = new InputStreamReader(process.getErrorStream());<br>LineNumberReader input = new LineNumberReader(isr);<br>String line;<br>while((line = input.readLine())!= null){<br>System.out.println(line+”<del>~</del><del>~</del>“);<br>}<br>System.out.println(“备份成功!”);<br>} catch (IOException e) {<br>System.out.println(“备份失败!”);<br>e.printStackTrace();<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/mysql数据库备份与恢复操作/" data-id="cixiraj35000bncp800tkn1s8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springMVC过滤器中的url-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/springMVC过滤器中的url-pattern/" class="article-date">
  <time datetime="2017-01-04T16:42:09.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/springMVC过滤器中的url-pattern/">springMVC过滤器中的url-pattern</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： spring</p>
<hr>
<p>/和/<em>的区别：<br>&lt; url-pattern &gt; / &lt;/ url-pattern &gt;   不会匹配到</em>.jsp，即：<em>.jsp不会进入spring的 DispatcherServlet类 。<br>&lt; url-pattern &gt; /</em> &lt;/ url-pattern &gt; 会匹配*.jsp，会出现返回jsp视图时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</p>
<p>总之，关于web.xml的url映射的小知识:<br><code>&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code>  会匹配到/login这样的路径型url，不会匹配到模式为<em>.jsp这样的后缀型url<br>`<url-pattern>/</url-pattern></em>` 会匹配所有url：路径型的和后缀型的url(包括/login,<em>.jsp,</em>.js和*.html等)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/springMVC过滤器中的url-pattern/" data-id="cixiraj3a000hncp8w9933n40" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-手动装配javabean的两种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/spring-手动装配javabean的两种方式/" class="article-date">
  <time datetime="2017-01-04T16:36:00.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/spring-手动装配javabean的两种方式/">spring-手动装配javabean的两种方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： spring</p>
<hr>
<p>有两种方式装配Bean（也算是spring提供的两种容器：beanfactory和applicationcontext）：</p>
<p>1）Bean工厂(Beanfactory)</p>
<p>2)应用上下文（ApplicationContext）</p>
<p>第一种方法使用org.springframework.beans.factory.BeanFactory接口来获得Bean对象实例。在Spring中有很多BeanFactory接口的实现，单最常用的是org.springframework.beans.factory.xml.XmlBeanFactory。通过XmlBeanFactory类可以从XML配置文件中读取Bean的装配信息，并在Spring容器中建立相应的JavaBean对象实例，并返回该JavaBean对象实例。</p>
<p>要想建立一个XmlBeanFactory对象实例，需要将配置文件通过FileSystemResource对象传入XmlBeanFactory类的构造方法。并通过BeanFactory类的getBean方法获得Bean的对象实例。eg:</p>
<p>package edu.xaut.jzd.spring;</p>
<p>import org.springframework.beans.factory.BeanFactory;<br>import org.springframework.beans.factory.xml.XmlBeanFactory;</p>
<p>import org.springframework.core.io.FileSystemResource;</p>
<p>public class HelloWorldTest {<br>public static void main(String[] args){<br>//装配applicationContext.xml文件<br>BeanFactory factory=new XmlBeanFactory(“src\applicationContext.xml”);<br>//获得被装配的HelloWorld对象实例<br>HelloWorld helloWorld = (HelloWorld)factory.getBean(“helloworld”);<br>System.out.println(helloWorld.getGreeting());<br>}<br>}</p>
<p>第二种方法通过org.springframework.context.ApplicationContext接口来装配Bean。在Spring中有如下两种ApplicationContext的实现经常用到。</p>
<p>FileSystemXmlApplicationContext：通过绝对或相对路径指定XML配置文件，并装载xml文件的配置信息。</p>
<p>ClassPathXmlApplicationContext：从类路径中搜索xml配置文件。可以使用FileSystemXmlApplicationContext类替换ClassPathXmlApplicationContext，但要将构造方法的参数值改为“applicationContext.xml”。</p>
<p>单从装配Bean上看，ApplicationContext和Beanfactory类似，但ApplicationContext比Beanfactory提供了更多的功能，如国际化、装载文件资源、向监听器Bean发送事件等。因此，如果要使用更多的功能，最好使用ApplicationContext来装配Bean。</p>
<p>装配普通属性时使用<code>&lt;property&gt;</code>和<code>&lt;value&gt;</code>标签即可完成装配工作。eg:</p>
<pre><code>&lt;bean id=&quot;helloworld&quot; class=&quot;edu.xaut.jzd.spring.HelloWorld&quot;&gt;
&lt;property name=&quot;greeting&quot; &gt;
&lt;value&gt;xautjzd&lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>一般不需要指定属性的类型（Spring会通过Java的反射机制确定属性的类型），单如果需要，可以使用<value>标签的type属性来指定属性类型。</value></p>
<p>如果属性类型是另外一个被装载的类，则有两种方法装配其属性值：</p>
<p>1）使用bean标签：</p>
<pre><code>&lt;bean id=&quot;helloworld&quot; class=&quot;edu.xaut.jzd.spring.HelloWorldImpl&quot;&gt;
&lt;property name=&quot;greeting&quot; &gt;
&lt;bean&gt;
&lt;property name=&quot;hello&quot;&gt;
&lt;value&gt;xautjzd&lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>2)使用ref标签：</p>
<pre><code>&lt;bean id=&quot;collectionBean&quot; class=&quot;com.tyq.collection.CollectionBean&quot;
            parent=&quot;abstractCollectionBean&quot;&gt;
            &lt;property name=&quot;list&quot;&gt;
                &lt;list merge=&quot;true&quot; value-type=&quot;java.lang.Object&quot;&gt;
                    &lt;value&gt;list1&lt;/value&gt;
                    &lt;ref local=&quot;collectionBean&quot; /&gt;
                    &lt;null&gt;&lt;/null&gt;
                &lt;/list&gt;
            &lt;/property&gt;
    &lt;/bean&gt;
</code></pre><p>ref标签容易和idref标签混淆。在spring 中idref是得到一个bean的id的string值而ref得到的是一个bean的实例</p>
<pre><code>&lt;bean id=&quot;collectionBean&quot; class=&quot;com.tyq.collection.CollectionBean&quot;
            parent=&quot;abstractCollectionBean&quot;&gt;
            &lt;property name=&quot;list&quot;&gt;
                &lt;list merge=&quot;true&quot; value-type=&quot;java.lang.String&quot;&gt;
                    &lt;value&gt;list1&lt;/value&gt;
                    &lt;idref local=&quot;collectionBean&quot; /&gt;
                    &lt;null&gt;&lt;/null&gt;
                &lt;/list&gt;
            &lt;/property&gt;
    &lt;/bean&gt;
</code></pre><p>这时加入list中的只是一个值为collectionBean的String实例而上面的ref标签加入的才是一个CollectionBean实例</p>
<p>在Spring中也可以装配集合类型属性，Spring支持的集合属性有：List、Set、Map和Properties。与这四种集合类型相对应的标签是list、set、map和pros。在装配集合类型属性时注意两点：<br>1）Bean的集合属性不需要使用new来建立对象实例，spring容器根据xml配置文件中的装配信息自动来实例化这些属性。<br>2）Spring分别为上述四种集合类型指定了如下的特定集合类来实例化。<br>list:java.util.ArrayList;<br>set:java.util.LinkedHashSet;<br>map:java.util.LinkedHashMap;<br>props:java.util.Properties;<br>Spring容器在自动实例化集合属性时，将使用上面的相应集合类来实例化相应的属性，读者在进行类型转换时应注意这一点。</p>
<p>装配构造方法<br>并不是每个JavaBean都只有一个无参构造方法，如果一个JavaBean的构造方法的参数有一个或多个，就需要使用constructor-arg标签来为这些构造方法设置相应的参数值。Spring搜索Bean的构造方法时，会将参数值都当成String类型数据看，除非明确指定了某一参数的类型。默认情况下，spring会根据constructor-arg的type属性来确定参数类型。同时也可以改变传递参数的顺序，用constructor-arg标签的index属性来指定，从0开始。eg:</p>
<pre><code>&lt;bean id=&quot;helloworld&quot; class=&quot;edu.xaut.jzd.spring.HelloWorld&quot;&gt;
&lt;property name=&quot;greeting&quot; &gt;
&lt;value&gt;xautjzd&lt;/value&gt;
&lt;/property&gt;
&lt;constructor-arg index=&quot;1&quot;&gt;
&lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;
&lt;constructor-arg index=&quot;0&quot;&gt;
&lt;value&gt;xautjzd&lt;/value&gt;
&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/spring-手动装配javabean的两种方式/" data-id="cixiraj36000cncp8g5y34lxc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-自动装配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/Spring-自动装配/" class="article-date">
  <time datetime="2017-01-04T16:24:31.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/Spring-自动装配/">Spring-自动装配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： spring</p>
<hr>
<p>自动装配:spring IOC容器可以自动装配（autowire），相互协作的bean之间的依赖关系,可以自动让spring查找beanFactory中的内容，来替我们指定bean的协作者，也就是其他被依赖的bean，autowire可以在单个bean中进行配置，所以可以给有的bean配置，给有的bean不配置，autowire的好处是可以减少或者消除属性和构造器参数的个数,其实就是减少几个ref；</p>
<p>当然,自动装配必须满足两点</p>
<p>(1)bean里面的属性名字必须和applicationContext.xml里面对应的bean id的名字相同..</p>
<p>(2)在申明里配置一个属性.default-autowire=”byName”(通过名字自动装配)</p>
<p>配置文件为.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&quot;
default-autowire=&quot;byName&quot;&gt;

default-autowire=&quot;x&quot;
</code></pre><p>x有4个选择：byName,byType,constructor和autodetect</p>
<p>autodetect：首先尝试使用construtor，然后使用byType方式;</p>
<p>constructor:<br>试图在容器中寻找与需要自动装配的bean的构造函数参数一致的一个或多个bean，如果没找到则抛出异常;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/Spring-自动装配/" data-id="cixiraj2v0003ncp892onz4p7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring单例详解与线程安全问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/Spring单例详解与线程安全问题/" class="article-date">
  <time datetime="2017-01-04T16:19:16.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/Spring单例详解与线程安全问题/">Spring单例详解与线程安全问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： spring</p>
<hr>
<p>Spring框架里的bean，或者称为组件，默认都是单例的。</p>
<p>单例模式意思就是一个类只有一个实例，自行实例化并且向整个系统提供这个实例；</p>
<p>如果多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时如果多线程并发的执行逻辑方法，并发的对单例的成员属性进行修改的时候，就要考虑多线程安全问题了，</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>1） 常量始终是线程安全的，因为只存在读操作。<br>2）每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。<br>3）局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。</p>
<p>解决线程安全问题的两种方法:</p>
<p>1.线程同步机制：通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>2.ThreadLocal：ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/Spring单例详解与线程安全问题/" data-id="cixiraj2w0004ncp8owz75x1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-依赖注入四种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/05/Spring-依赖注入四种方式/" class="article-date">
  <time datetime="2017-01-04T16:00:53.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/05/Spring-依赖注入四种方式/">Spring-依赖注入四种方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）： spring</p>
<hr>
<p>平常的java开发中，程序员在某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做。</p>
<p>spring有多种依赖注入的形式，下面仅介绍spring通过xml进行IOC配置的方式：<br>Set注入<br>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）：<br>Java代码  收藏代码<br>package com.bless.springdemo.action;<br>public class SpringAction {<br>        //注入对象springDao<br>    private SpringDao springDao;<br>        //一定要写被注入对象的set方法<br>        public void setSpringDao(SpringDao springDao) {<br>        this.springDao = springDao;<br>    }<br>        public void ok(){<br>        springDao.ok();<br>    }<br>}</p>
<p>随后编写spring的xml文件，<bean>中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在<bean>标签中创建一个<property>标签指定SpringDao。<property>标签中的name就是SpringAction类中的SpringDao属性名，ref指下面<bean name="springDao" ...="">，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入：<br>Java代码</bean></property></property></bean></bean></p>
<pre><code>&lt;!--配置bean,配置后该类由spring管理--&gt;
    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;
        &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt;
        &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre><p>构造器注入<br>这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来：<br>Java代码<br>public class SpringAction {<br>    //注入对象springDao<br>    private SpringDao springDao;<br>    private User user;<br>    public SpringAction(SpringDao springDao,User user){<br>        this.springDao = springDao;<br>        this.user = user;<br>        System.out.println(“构造方法调用springDao和user”);<br>    }<br>        public void save(){<br>        user.setName(“卡卡”);<br>        springDao.save(user);<br>    }<br>}</p>
<p>在XML文件中同样不用<property>的形式，而是使用<constructor-arg>标签，ref属性同样指向其它<bean>标签的name属性：<br>Xml代码</bean></constructor-arg></property></p>
<pre><code>&lt;!--配置bean,配置后该类由spring管理--&gt;
    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;
        &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt;
        &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
        &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt;
         &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt;
</code></pre><p>  解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理：<br>下面是设置index，就是参数位置：<br>Xml代码  收藏代码</p>
<pre><code>&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg index=&quot;1&quot; ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
  另一种是设置参数类型：
Xml代码
&lt;constructor-arg type=&quot;java.lang.String&quot; ref=&quot;&quot;/&gt;
</code></pre><p>静态工厂的方法注入<br>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取：<br>Java代码  收藏代码<br>package com.bless.springdemo.factory;<br>import com.bless.springdemo.dao.FactoryDao;<br>import com.bless.springdemo.dao.impl.FactoryDaoImpl;<br>import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;<br>public class DaoFactory {<br>    //静态工厂<br>    public static final FactoryDao getStaticFactoryDaoImpl(){<br>        return new StaticFacotryDaoImpl();<br>    }<br>}</p>
<p>同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别:<br>Java代码<br> public class SpringAction {<br>        //注入对象<br>    private FactoryDao staticFactoryDao;<br>    public void staticFactoryOk(){<br>        staticFactoryDao.saveFactory();<br>    }<br>    //注入对象的set方法<br>    public void setStaticFactoryDao(FactoryDao staticFactoryDao) {<br>        this.staticFactoryDao = staticFactoryDao;<br>    }<br>}</p>
<p>Spring的IOC配置文件，注意看<code>&lt;bean name=&quot;staticFactoryDao&quot;&gt;</code>指向的class并不是FactoryDao的实现类，而是指向静态工厂DaoFactory，并且配置 factory-method=”getStaticFactoryDaoImpl”指定调用哪个工厂方法：<br>Xml代码</p>
<pre><code>&lt;!--配置bean,配置后该类由spring管理--&gt;
    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot; &gt;
        &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt;
        &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt;
                &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt;
    &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre><p>实例工厂的方法注入<br>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法：<br>Java代码<br>public class DaoFactory {<br>    //实例工厂<br>    public FactoryDao getFactoryDaoImpl(){<br>        return new FactoryDaoImpl();<br>    }<br>}<br>那么下面这个类没什么说的，跟前面也很相似，但是我们需要通过实例工厂类创建FactoryDao对象：<br>Java代码<br>public class SpringAction {<br>    //注入对象<br>    private FactoryDao factoryDao;<br>    public void factoryOk(){<br>        factoryDao.saveFactory();<br>    }<br>    public void setFactoryDao(FactoryDao factoryDao) {<br>        this.factoryDao = factoryDao;<br>    }<br>}</p>
<p>最后看spring配置文件：<br>Xml代码</p>
<pre><code>&lt;!--配置bean,配置后该类由spring管理--&gt;
    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;
        &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt;
        &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt;
    &lt;bean name=&quot;daoFactory&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot;&gt;&lt;/bean&gt;
    &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre><p>总结<br>Spring IOC注入方式用得最多的是(1)(2)种，多谢多练就会非常熟练。<br>        另外注意：通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在<code>&lt;bean&gt;</code>标签后面添加一个属性：<br>Java代码</p>
<pre><code>&lt;bean name=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2017/01/05/Spring-依赖注入四种方式/" data-id="cixiraj2r0001ncp82qppmyyf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring如何管理对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/29/spring如何管理对象/" class="article-date">
  <time datetime="2016-12-29T11:37:57.000Z" itemprop="datePublished">2016-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/29/spring如何管理对象/">spring如何管理对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先说一下什么是spring，spring是一个对象仓库（容器）,spring的目的是为了解耦,减少类与类之间的耦合度;</p>
<p>spring如何管理对象呢？</p>
<p>1.spring通过反射创建对象，a.在spring容器初始化时，默认会创建所有对象，                                                                b.如果配置了lazy-init延迟创建，初始化时不创建，需要创                                                     建的时候再创建。                                                                   2.装配         a.手动装配。手动装配有两种方式，一种是beanFactory，另一种是应用上                                             下文（ApplicationContext;                                                                               b.自动装配;</p>
<p>3.对象的获取:默认是单例的，多线程修改单例的bean的属性会造成线程安全问题，设置属性为protoType原型复制副本，解决线程安全问题;</p>
<p>4、容器销毁时，销毁所有的对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://monsmile.github.io/2016/12/29/spring如何管理对象/" data-id="cixiraj3e000lncp8okcu2y2r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/05/获取insert数据的主键/">mybatis获取insert数据的主键</a>
          </li>
        
          <li>
            <a href="/2017/01/05/springMVC常用注解/">springMVC常用注解</a>
          </li>
        
          <li>
            <a href="/2017/01/05/MySQL修改root密码的多种方法/">MySQL修改root密码的多种方法</a>
          </li>
        
          <li>
            <a href="/2017/01/05/mysql数据库备份与恢复操作/">mysql数据库备份与恢复操作</a>
          </li>
        
          <li>
            <a href="/2017/01/05/springMVC过滤器中的url-pattern/">springMVC过滤器中的url-pattern</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 gaolanyu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>